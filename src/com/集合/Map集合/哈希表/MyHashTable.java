package com.集合.Map集合.哈希表;

/**
 * @author Doraemon
 * @version 1.0
 * @date 2021/10/1 4:33 下午
 */

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * 哈希表 或者叫做 散列表数据结构
 * 1、HashMap 的底层数据结构？
 *      底层是哈希表 / 散列表的数据结构
 * 2、哈希表是什么样子的数据结构？
 *      哈希表是一个数组和链表的结合体；
 *      数组：在查询方面效率比较高，在随机增删方面的效率比较低下；
 *      链表：在随机增删方面的效率比较低下，在查询方面的效率很低；
 *      哈希表将上面的两种数据结构进行结合，充分发挥各自的优点；
 * 3、HashMap集合底层的源代码
 *      public class HashMap{
 *          // 实际上是一个数组（一纬的数组）
 *          Node<K,V>[] table;
 *
 *          // 静态的内部类
 *          static class Node<K,V> {
 *              final int hash;     // 哈希值，是 key 的hashCode() 方法执行结果，哈希值通过了哈希函数的算法，转换成为了数组的下标
 *              final K key;        // 存储带 Map 集合中的 key
 *              V value;            // 存储到 Map 集合中的 value
 *              Node<K,V> next;     // 下一个节点的内存地址
 *          }
 *      }
 *
 *      哈希表 / 散列表：是一个一维数组，数组中的每一个元素是一个单向链表，数组和链表的结合体
 *
 * 4、需要掌握的是：
 *      map.put(k,v);
 *      v = map.get(k);
 *      上面的两个方法是需要掌握的；
 *
 *          map.put(k,v) 实现原理；
 *              1、将 k,v 封装到 Node 对象之中
 *              2、底层调用 key 的hashCode() 方法得到 hash 值，通过哈希函数/哈希算法将 hash 值转换为数组的下标，
 *                 下标的位置上面如果没有任何的元素，就将 Node 添加到这个位置上面，如果说下面对应的位置上面，有链表节点，
 *                 此时会拿着 key 和链表的每一个节点进行 equals ，如果所有的 equals 返回的都是 false ，这个节点会添加到链表的结尾
 *                 如果其中有一个 equals 返回了true ，那么将相等节点上面的 value 替换掉即可；
 *
 *          map.get(k) 实现原理：
 *              1、先调用 k 的hashCode 方法得到哈希值，通过哈希算法转换成为数组下标；
 *              2、通过数组下标快速定位到某个位置上面，如果这个位置上面什么也没有，返回 null ，如果在这个位置上面有一个单向链表（因为
 *                 产生了哈希冲突），会拿着参数 key 和单向链表上面的节点中的 key 进行 equals ,所有的 equals 方法返回 false，
 *                 get 返回 null ，只要有其中的一个节点返回的是 true ，说明这个时候已经找到了自己想要找到的元素，那么返回这个节点
 *                 的 value 即可；
 *
 * 5、为什么哈希表的随机增删以及查询的效率都是比较高的？
 *      因为随机增删是在链表上面操作的（选择了这个处理哈希冲突的方式，有了冲突直接形成一个链表）；
 *      因为索引是在数组上面进行的，使用了哈希函数，将 key 转换成为了数组中的下标，查询时候，只需要扫描其中的一个即可；
 *      没有纯数组和纯链表的性能好，这是一个结合体，是一个中间的选择；
 *
 * 6、总结上面的内容：HashMap 集合中的 key ,会先后使用了两个方法，一个是 hashCode(),一个是equals 方法，需要对其进行重写；
 *
 * 7、为什额需要重写 equals 方法？
 *      因为 equals 方法默认比较的是两个对象的地址，现在需要比较内容才能进行下一步的操作；
 *
 * 8、HashMap 集合中 key 的特点：
 *      无序，不可重复
 *          为什么无序？
 *              因为在加入的时候，不知道会加入到什么地方，随机的链表的添加
 *          为什么不可重复？
 *              因为加入的时候，重复的东西被覆盖掉了，equals 方法对此进行了保证；
 *
 * 9、放在了 HashMap com.集合 key 的部分就是放在了 HashSet 集合中了；
 *    放在了 HashSet 集合中的元素同时也是需要重写 hashCode() 和 equals() 方法的
 *
 * 10、同一个单向链表上面的节点的 hash 值是相同的，因为他们的下标是相同的；下标是 hashCode 经过了哈希函数经过一定的处理之后，产生的
 *     产生的路子是一样的，所以在这里的 hash 值是相同的；
 *     同一个链表方面的 key 进行 equals() 方法比较的时候，一定是 false 因为，存放数据的时候就已经保证了；
 *
 * 11、哈希表在使用时候，需要设计良好的哈希函数，否则会导致设计出来的东西放成了一个单向链表，就不能发挥出来它的性能了；
 *     （也就是 hashCede 一直是一个值，只会在一个链表上面存储元素），叫做散列分布不均匀；
 *     散列分布均匀是比较好的；数组链表，同时发挥自己应该发挥的性能；
 *
 *     散列分布均匀，需要重写 hashCode() 方法，有一定的技巧
 *
 * 12、领悟哈希算法，这是一种思想
 *     不定长的字符串，经过了哈希之后，变成了定长；
 *
 * 13、重点：
 *     放在了 HashMap 集合key 部分的元素和放在了 HashSet 集合中的元素，需要对hashCode() 和 equals() 方法进行重写
 *
 * 14、HashMap 集合的默认初始化容量是 16 ，默认加载因子是 0.75;
 *     当 HashMap 的数组达到 0.75 的时候，数组就会进行启动扩容，不是满了才会扩容，是达到 0.75 就会扩容；
 *     HashMap 进行大小的初始化的时候，容量最好为 2 的倍数，这是推荐的量，因为达到散列分布均匀，为了提高哈希的存储效率所需要的；
 *     不是 2 的倍数会使得哈希表的性能减少， 2 的倍数需要熟记；
 *
 * 15、关于在哈希表中的链表的节点数目大于 8 的时候，会将节点转换成为红黑树，当节点的数目小于 6 的时候，会继续变成单向链表；
 *     这种方式是为了提高检索效率
 *
 * 16、初始化容量是 16 默认加载因子是.75
 */

/**
 * 需要掌握的几个知识点：
 *      1、对相关的添加元素的方法能够使用
 *      2、能够对于HashMap 里面的元素进行迭代即可
 *      3、记住在自己写的类中的 hashCode() 和 equals() 方法是需要重写的；而且是同时重写的；
 *         没有哈希碰撞的情况下，放多少元素，就会产生多少个下标，在这里的哈希碰撞需要后期的学习；看具体的哈希算法，也就是添加元素的方式
 *         先调用 hashCode() 然后调用 equals() 方法；
 *
 *      4、对于哈希表数据结构来说：
 *              如果 哦o1 和 o2 的值相同时，一定放到同一个单向链表上面；
 *              当然当 o1 和 o2 的值不同的时候，由于哈希算法，也是有可能放在同一个单向链表上面的，是因为哈希碰撞的产生；
 */
public class MyHashTable {
    public static void main(String[] args) {
        // 测试 HashMap 集合中存储数据元素的特点
        // Integer 里面的 hashCode equals() 方法都已经重写了
        // 使用泛型机制，限定元素的添加
        HashMap<Integer,String> map = new HashMap<>();
        map.put(1,"a");
        map.put(2,"b");
        map.put(3,"c");
        map.put(1,"d");
        map.put(1,"e");
        System.out.println(map.size()); // 3 因为在key 重复的时候，value 会被覆盖掉

        // 对于 Map 集合的遍历
        // map 在经过了 entrySet 之后，将这个转换成为了 Set com.集合；并且在它的左边使用了一个 Set 集合接受此物；下面使用了增强 for 循环；
        // 在这里， Set 集合中存储的是 一个 Entry ，也就是一个键值对，下面遍历时候，分别遍历键值对，分开；
        Set<Map.Entry<Integer,String>> set = map.entrySet();
        for (Map.Entry<Integer,String> entry : set) {
            // 验证结果：HashMap com.集合 key 部分元素，没有顺序并且是不可以重复的
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
    }
}