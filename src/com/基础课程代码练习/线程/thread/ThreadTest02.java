package com.基础课程代码练习.线程.thread;

/**
 * @author Doraemon
 * @version 1.0
 * @date 2021/10/7 10:34 下午
 */

/**
 * 实现线程的第一个方式：
 *      编写一个类直接继承 java.lang.Thread 方法，进行 run 方法的重写即可
 *
 * 如何创建线程对象？怎么启动线程？
 *      创建：main 方法，这里的代码是属于主线程的，在主栈中运行
 *          new 即可
 *      启动：新建一个分支线程对象
 *          调用线程中的 start 即可
 *
 * 方法体里面的代码是从上到下面按照顺序执行的，是不会变的；
 */

/**
 * 下面的程序的输出特点：
 *      有先有后，有多有少？如何解释？
 *          1、控制台只有一个
 *          2、线程抢到了执行权
 *              1、new 出来的线程对象（处于新建状态）
 *              2、调用 start 方法，进去就绪状态
 *                  就绪状态也叫做可运行状态，表示当前线程具有抢夺CPU 时间片的权利（CPU 时间片就是执行权）。当一个线程抢到了CPU
 *                  时间片之后，开始执行 run 方法，run 方法开始执行的时候，标志着线程进入到了运行状态
 *              3、运行状态
 *                  run 方法开始执行，标志者程序进去运行状态，但是在之前的CPU 时间片被使用结束之后，重新回去就绪状态准备抢CPU 时间片
 *              4、在运行状态和就绪状态时间之间，是需要使用 JVM 进行资源的分配的
 *              5、最后程序中的线程周期将会结束
 *              6、当一个线程遇到了阻塞状态的时候，比如接收用户的键盘输入，或者使用sleep() 方法等；
 *                 此时的线程会进入阻塞状态，阻塞状态的线程会放弃之前占有的CPU 时间片；
 *                 当阻塞状态结束后，当前的程序会进去就绪状态，在这里分配到到了CPU 时间片之后，才会进行运行状态；
 *
 *
 * 关于线程对象的生命周期？
 *      新建状态
 *      就绪状态
 *      运行状态
 *      阻塞状态
 *      死忙状态
 */
public class ThreadTest02 {
    public static void main(String[] args) {
        // 在这里是main 方法，代码属于主线程，在主栈中运行
        MyThread myThread = new MyThread();

        // 线程的启动
        // start 方法中的作用：
        // 启动一个分支线程，在 JVM 中开辟一个新的栈空间，启这段代码任务完成之后瞬间就结束了，
        // 这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开辟出来 start() 方法就结束了，线程就启动成功了
        // 启动成功的线程，会自动调用 run 方法，并且在 run 方法在分支栈的底部（压栈）最先进去的，所以在最底部；
        // run 方法在分支栈的底部，main 方法在主栈的底部，run 和 main 是平级别的；

//        myThread.run(); // 就是普通的单线程 不会启动分支栈，不会启动分支线程


        myThread.start(); // 瞬间结束这一句，开辟了栈空间就结束
        // myThread.run() 如果只是调用了这一个方法，那么就是只是调用了方法，没有使用新的线程，不会分配新的分支栈
        // 分支线程启动开始，主线程了分支线程都在执行了

        // 这里的代码运行在主线程中
        for (int i = 0; i < 1000; i++) {
            System.out.println("主线程-->" + i);
        }
    }
}

class MyThread extends Thread {
    // 对于继承方法的重写，实现多线程
    // run 在下面是不需要手动调用的，JVM 会自动进行调用
    @Override
    public void run() {
        // 编写程序，这段程序运行在分支栈中
        for (int i = 0; i < 1000; i++) {
            System.out.println("分支线程 -->" + i);
        }
    }
}